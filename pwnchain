#!/usr/bin/env python3
#
# PwnChain - Cascading different tools in automated fashion.
# Copyright (C) 2021 Nikolas Beisemann <nikolas@disroot.org>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""PwnChain is a tool for cascading different tools in an automated fashion."""


import logging
import re
from subprocess import Popen, PIPE
from threading import Thread
from argparse import ArgumentParser, RawTextHelpFormatter
import json

VERSION = "0.2.0"
TASK_POOL = []

def exec_cmd(cmd, logger, logfile):
    """Generator executing a command yielding output.

    Keyword arguments:
    cmd -- Command to execute as string
    logger -- Used for logging
    logfile -- Read output is stored to that file if not None
    """
    with Popen(cmd.split(), stdout = PIPE, stderr = None, universal_newlines = True,
        bufsize = 1) as proc:
        logfile_fp = None
        if logfile:
            try:
                logfile_fp = open(logfile, "w")
            except OSError:
                logger.warning(f"failed to open {logfile} for writing")
        for line in proc.stdout:
            logger.debug(line)
            if logfile_fp:
                logfile_fp.write(line)
            yield line


def run_tool(module, save_logfiles, var):
    """Runs a single module defined in the config json.

    Keyword arguments:
    module -- json config pointing to the current module
    save_logfiles -- bool flag indicating whether to save module output
    var -- variables currently known to the module

    Calls itself recursively, if matches are found and modules are defined in the post attribute.
    A new thread is spawned for each match.
    """
    for (var_key, var_val) in module["vars"].items():
        var[var_key] = var_val
    logger = logging.getLogger(module["name"].format(**var))

    if "enabled" in module:
        if not module["enabled"]:
            logger.debug("skipping because module is disabled")
            return
    if "condition" in module:
        condition = module["condition"].format(**var)
        if eval(condition):
            logger.debug(f"pre-condition '{condition}' passed")
        else:
            logger.debug(f"skipping because of pre-condition '{condition}'")
            return

    cmd = module["cmd"].format(**var)
    patterns = []
    for pattern_dict in module["patterns"]:
        patterns.append({
            "pattern": re.compile(pattern_dict["pattern"].format(**var)),
            "groups": pattern_dict["groups"],
            "log": pattern_dict["log"]
            })
    logfile = None
    if save_logfiles and "logfile" in module:
        logfile = module["logfile"].format(**var)
    logger.debug(f"var={var}")
    logger.debug(f"cmd={cmd}")

    for line in exec_cmd(cmd, logger, logfile):
        for entry in patterns:
            match = entry["pattern"].match(line)
            if match:
                idx = 1
                for group in entry["groups"]:
                    var[group] = match.group(idx)
                    idx += 1
                if "log" in entry:
                    logger.info(entry["log"].format(**var))
                for task in module["post"]:
                    sub_task = Thread(target = run_tool, args = (task, save_logfiles, var))
                    sub_task.start()
                    TASK_POOL.append(sub_task)


def update_cfg_vars(cfg, mod, key, val):
    """Update variables of module and all submodules."""
    if re.search(mod, cfg["name"]):
        for var in cfg["vars"]:
            if re.search(key, var):
                logging.debug(f"set {cfg['name']}.vars.{var}={val}")
                cfg["vars"][var] = val
    for subcfg in cfg["post"]:
        update_cfg_vars(subcfg, mod, key, val)


def update_cfg_enabled(cfg, mod, enabled):
    """Update enabled state of module and all submodules."""
    if re.search(mod, cfg["name"]):
        cfg["enabled"] = enabled
        logging.debug(f"set {cfg['name']}.enabled={enabled}")
    for subcfg in cfg["post"]:
        update_cfg_enabled(subcfg, mod, enabled)


if __name__ == '__main__':
    parser = ArgumentParser(formatter_class = RawTextHelpFormatter)
    parser.add_argument("--version", action = "version", version = VERSION)
    with open("LICENSE") as fp:
        parser.add_argument("--show-license", action = "version", version = fp.read(),
            help = "show program's license details and exit")
    parser.add_argument("-v", "--verbose", action = "store_true",
        help = "print debug log messages")
    parser.add_argument("-o", "--save-logfiles", action = "store_true",
        help = "save the output of each command to the specified logfile")
    parser.add_argument("-s", "--set-var", action = "append", metavar = "module:key:val",
        help = "override a module variable specified within the configuration")
    parser.add_argument("--enable-mod", action = "append", metavar="module",
        help = "enable a module which is marked enabled=False in the configuration")
    parser.add_argument("--disable-mod", action = "append", metavar="module",
        help = "disable a module which is marked enabled=True in the configuration")
    parser.add_argument("cfg", help = ".json configuration file")

    args = parser.parse_args()

    print(f"""==========================================================================
= PwnChain v{VERSION}                                                        =
==========================================================================
= Copyright (C) 2021 Nikolas Beisemann <nikolas@disroot.org>.            =
= This program comes with ABSOLUTELY NO WARRANTY; for details use        =
= '--show-license'.                                                      =
= This is free software, and you are welcome to redistribute it under    =
= certain conditions; use '--show-license' for details.                  =
==========================================================================
    """)

    if args.verbose:
        logging.basicConfig(level = logging.DEBUG)
        logging.debug("verbose tracing enabled")
    else:
        logging.basicConfig(level = logging.INFO)

    json_cfg = json.load(open(args.cfg))
    logging.debug(f"config {args.cfg} read")

    if args.set_var:
        for entry in args.set_var:
            (e_mod, e_key, e_val) = entry.split(':')
            logging.debug(f"trying to override variable '{e_key}={e_val}' in '{e_mod}'")
            update_cfg_vars(json_cfg, e_mod, e_key, e_val)
    if args.enable_mod:
        for entry in args.enable_mod:
            update_cfg_enabled(json_cfg, entry, True)
    if args.disable_mod:
        for entry in args.disable_mod:
            update_cfg_enabled(json_cfg, entry, False)

    run_tool(json_cfg, args.save_logfiles, {})
    for t in TASK_POOL:
        t.join()
