#!/usr/bin/env python3
#
# PwnChain - Cascading different tools in automated fashion.
# Copyright (C) 2021 Nikolas Beisemann <nikolas@disroot.org>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.


import logging
import re

version = "0.1.0"
task_pool = []

def exec_cmd(cmd, logger, logfile):
	"""Generator executing a command yielding output.

	Keyword arguments:
	cmd -- Command to execute as string
	logger -- Used for logging
	logfile -- Read output is stored to that file if not None
	"""
	from subprocess import Popen, PIPE

	with Popen(cmd.split(), stdout = PIPE, stderr = None, universal_newlines = True, bufsize = 1) as proc:
		fp = None
		if logfile:
			try:
				fp = open(logfile, "w")
			except OSError:
				logger.warning(f"failed to open {logfile} for writing")
		for line in proc.stdout:
			logger.debug(line)
			if fp:
				fp.write(line)
			yield line


def run_tool(cfg, save_logfiles, var = {}):
	"""Runs a single module defined in the config json.

	Keyword arguments:
	cfg -- json config pointing to the current module
	save_logfiles -- bool flag indicating whether to save module output
	var -- variables currently known to the module

	Calls itself recursively, if matches are found and modules are defined in the post attribute.
	A new thread is spawned for each match.
	"""
	from threading import Thread

	for (key, val) in cfg["vars"].items():
		var[key] = val
	logger = logging.getLogger(cfg["name"].format(**var))

	if "enabled" in cfg:
		if not cfg["enabled"]:
			logger.debug("skipping because module is disabled")
			return
	if "condition" in cfg:
		condition = cfg["condition"].format(**var)
		if eval(condition):
			logger.debug(f"pre-condition '{condition}' passed")
		else:
			logger.debug(f"skipping because of pre-condition '{condition}'")
			return

	cmd = cfg["cmd"].format(**var)
	patterns = []
	for entry in cfg["patterns"]:
		patterns.append({ 
			"pattern": re.compile(entry["pattern"].format(**var)),
			"groups": entry["groups"],
			"log": entry["log"]
			})
	logfile = None
	if save_logfiles and "logfile" in cfg:
		logfile = cfg["logfile"].format(**var)
	logger.debug(f"var={var}")
	logger.debug(f"cmd={cmd}")

	for line in exec_cmd(cmd, logger, logfile):
		for entry in patterns:
			match = entry["pattern"].match(line)
			if match:
				idx = 1
				for group in entry["groups"]:
					var[group] = match.group(idx)
					idx += 1
				if "log" in entry:
					logger.info(entry["log"].format(**var))
				for task in cfg["post"]:
					t = Thread(target = run_tool, args = (task, save_logfiles, var))
					t.start()
					task_pool.append(t)


def update_cfg_vars(cfg, mod, key, val):
	"""Update variables of module and all submodules."""
	if re.search(mod, cfg["name"]):
		for var in cfg["vars"]:
			if re.search(key, var):
				logging.debug(f"set {cfg['name']}.vars.{var}={val}")
				cfg["vars"][var] = val
	for subcfg in cfg["post"]:
		update_cfg_vars(subcfg, mod, key, val)


def update_cfg_enabled(cfg, mod, enabled):
	"""Update enabled state of module and all submodules."""
	if re.search(mod, cfg["name"]):
		cfg["enabled"] = enabled
		logging.debug(f"set {cfg['name']}.enabled={enabled}")
	for subcfg in cfg["post"]:
		update_cfg_enabled(subcfg, mod, enabled)


if __name__ == '__main__':
	from argparse import ArgumentParser, RawTextHelpFormatter
	from sys import exit
	import json

	parser = ArgumentParser(formatter_class = RawTextHelpFormatter)
	parser.add_argument("--version", action = "version", version = version)
	with open("LICENSE") as fp:
		parser.add_argument("--show-license", action = "version", version = fp.read(),
			help = "show program's license details and exit")
	parser.add_argument("-v", "--verbose", action = "store_true",
		help = "print debug log messages")
	parser.add_argument("-o", "--save-logfiles", action = "store_true",
		help = "save the output of each command to the specified logfile")
	parser.add_argument("-s", "--set-var", action = "append", metavar = "module:key:val",
		help = "override a module variable specified within the configuration")
	parser.add_argument("--enable-mod", action = "append", metavar="module",
		help = "enable a module which is marked enabled=False in the configuration")
	parser.add_argument("--disable-mod", action = "append", metavar="module",
		help = "disable a module which is marked enabled=True in the configuration")
	parser.add_argument("cfg", help = ".json configuration file")

	args = parser.parse_args()

	print(f"""==========================================================================
= PwnChain v{version}                                                        =
==========================================================================
= Copyright (C) 2021 Nikolas Beisemann <nikolas@disroot.org>.            =
= This program comes with ABSOLUTELY NO WARRANTY; for details use        =
= '--show-license'.                                                      =
= This is free software, and you are welcome to redistribute it under    =
= certain conditions; use '--show-license' for details.                  =
==========================================================================
	""")

	if args.verbose:
		logging.basicConfig(level = logging.DEBUG)
		logging.debug("verbose tracing enabled")
	else:
		logging.basicConfig(level = logging.INFO)

	cfg = json.load(open(args.cfg))
	logging.debug(f"config {args.cfg} read")

	if args.set_var:
		for entry in args.set_var:
			(mod, key, val) = entry.split(':')
			logging.debug(f"trying to override variable '{key}={val}' in '{mod}'")
			update_cfg_vars(cfg, mod, key, val)
	if args.enable_mod:
		for entry in args.enable_mod:
			update_cfg_enabled(cfg, entry, True)
	if args.disable_mod:
		for entry in args.disable_mod:
			update_cfg_enabled(cfg, entry, False)

	run_tool(cfg, args.save_logfiles)
	for t in task_pool:
		t.join()