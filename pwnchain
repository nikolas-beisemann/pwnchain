#!/usr/bin/env python3
#
# PwnChain - Cascading different tools in automated fashion.
# Copyright (C) 2021 Nikolas Beisemann <nikolas@disroot.org>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""PwnChain is a tool for cascading different tools in an automated fashion."""


import logging
import re
from subprocess import Popen, PIPE
from threading import Thread
from argparse import ArgumentParser, RawTextHelpFormatter
import json
from os import path

VERSION = "0.2.0"

class Module:
    """Represents a single module as defined in the config json."""

    def __init__(self, thread_pool, cfg, var):
        """Set up run environment."""
        self.thread_pool = thread_pool
        self.cfg = cfg
        self.var = var.copy()
        for (key, val) in self.cfg["vars"].items():
            self.var[key] = val
        self.logger = logging.getLogger(self.cfg["name"].format(**self.var))


    def run(self, save_logfiles):
        """Spawn module in separate thread."""
        thread = Thread(target = self.run_worker, args = (save_logfiles,))
        thread.start()
        self.thread_pool.append(thread)


    def run_worker(self, save_logfiles):
        """Run module."""
        if self.should_not_run():
            return
        cmd = self.cfg["cmd"].format(**self.var)
        patterns = []
        for pattern_dict in self.cfg["patterns"]:
            patterns.append({
                "pattern": re.compile(pattern_dict["pattern"].format(**self.var)),
                "groups": pattern_dict["groups"],
                "log": pattern_dict["log"]
                })
        logfile = None
        if save_logfiles and "logfile" in self.cfg:
            logfile = save_logfiles + path.sep + self.cfg["logfile"].format(**self.var)
        self.logger.debug("var=%s", self.var)
        self.logger.debug("cmd=%s", cmd)

        for line in self.exec_cmd(cmd, logfile):
            for pattern_dict in patterns:
                match = pattern_dict["pattern"].match(line)
                if match:
                    idx = 1
                    for group in pattern_dict["groups"]:
                        self.var[group.format(**self.var)] = match.group(idx)
                        idx += 1
                    if "log" in pattern_dict:
                        self.logger.info(pattern_dict["log"].format(**self.var))
                    for post_task in self.cfg["post"]:
                        sub_task = Module(self.thread_pool, post_task, self.var)
                        sub_task.run(save_logfiles)


    def should_not_run(self):
        """Check if preconditions for running the module are given."""
        if "enabled" in self.cfg:
            if not self.cfg["enabled"]:
                self.logger.debug("skipping because module is disabled")
                return True
        if "condition" in self.cfg:
            condition = self.cfg["condition"].format(**self.var)
            if eval(condition):
                self.logger.debug("pre-condition '%s' passed", condition)
            else:
                self.logger.debug("skipping because of pre-condition '%s'", condition)
                return True
        return False


    def exec_cmd(self, cmd, logfile):
        """Generator executing a command yielding output.

        Keyword arguments:
        cmd -- Command to execute as string
        logger -- Used for logging
        logfile -- Read output is stored to that file if not None
        """
        with Popen(cmd.split(), stdout = PIPE, stderr = None, universal_newlines = True,
            bufsize = 1) as proc:
            logfile_fp = None
            if logfile:
                try:
                    logfile_fp = open(logfile, "w")
                except OSError:
                    self.logger.warning("failed to open %s for writing", logfile)
            for line in proc.stdout:
                self.logger.debug(line)
                if logfile_fp:
                    logfile_fp.write(line)
                yield line


def update_cfg_vars(cfg, mod, key, val):
    """Update variables of module and all submodules."""
    if re.search(mod, cfg["name"]):
        for var in cfg["vars"]:
            if re.search(key, var):
                logging.debug("set %s.vars.%s=%s", cfg['name'], var, val)
                cfg["vars"][var] = val
    for subcfg in cfg["post"]:
        update_cfg_vars(subcfg, mod, key, val)


def update_cfg_enabled(cfg, mod, enabled):
    """Update enabled state of module and all submodules."""
    if re.search(mod, cfg["name"]):
        cfg["enabled"] = enabled
        logging.debug("set %s.enabled=%s", cfg['name'], enabled)
    for subcfg in cfg["post"]:
        update_cfg_enabled(subcfg, mod, enabled)


if __name__ == '__main__':
    parser = ArgumentParser(formatter_class = RawTextHelpFormatter)
    parser.add_argument("--version", action = "version", version = VERSION)
    with open("LICENSE") as fp:
        parser.add_argument("--show-license", action = "version", version = fp.read(),
            help = "show program's license details and exit")
    parser.add_argument("-v", "--verbose", action = "store_true",
        help = "print debug log messages")
    parser.add_argument("-o", "--save-logfiles", metavar = "directory",
        help = "save the output of each command to a given directory")
    parser.add_argument("-s", "--set-var", action = "append", metavar = "module:key:val",
        help = "override a module variable specified within the configuration")
    parser.add_argument("--enable-mod", action = "append", metavar="module",
        help = "enable a module which is marked enabled=False in the configuration")
    parser.add_argument("--disable-mod", action = "append", metavar="module",
        help = "disable a module which is marked enabled=True in the configuration")
    parser.add_argument("cfg", help = ".json configuration file")

    args = parser.parse_args()

    print(f"""==========================================================================
= PwnChain v{VERSION}                                                        =
==========================================================================
= Copyright (C) 2021 Nikolas Beisemann <nikolas@disroot.org>.            =
= This program comes with ABSOLUTELY NO WARRANTY; for details use        =
= '--show-license'.                                                      =
= This is free software, and you are welcome to redistribute it under    =
= certain conditions; use '--show-license' for details.                  =
==========================================================================
    """)

    if args.verbose:
        logging.basicConfig(level = logging.DEBUG)
        logging.debug("verbose tracing enabled")
    else:
        logging.basicConfig(level = logging.INFO)

    json_cfg = json.load(open(args.cfg))
    logging.debug("config %s read", args.cfg)

    if args.set_var:
        for entry in args.set_var:
            (e_mod, e_key, e_val) = entry.split(':')
            logging.debug("trying to override variable '%s=%s' in '%sq'", e_key, e_val, e_mod)
            update_cfg_vars(json_cfg, e_mod, e_key, e_val)
    if args.enable_mod:
        for entry in args.enable_mod:
            update_cfg_enabled(json_cfg, entry, True)
    if args.disable_mod:
        for entry in args.disable_mod:
            update_cfg_enabled(json_cfg, entry, False)

    task_pool = []
    task = Module(task_pool, json_cfg, {})
    task.run(args.save_logfiles)
    for thrd in task_pool:
        thrd.join()
